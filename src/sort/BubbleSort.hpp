//
// Created by pl on 2020/9/24.
//

#ifndef ALGORITHM_BUBBLESORT_HPP
#define ALGORITHM_BUBBLESORT_HPP
#include <vector>

namespace Algo {
    namespace Sort {

        template <typename T>
        void BubbleSort(std::vector<T> &data) {
            // 遍历n躺，i 表示已经遍历的趟数，每遍历一趟，都有一个元素处于正确的位置上。
            for (size_t i = 0; i < data.size(); i++) {

                // -i：表示已经遍历过的趟数（即已经有i个元素在正确的位置上），就不用在对其进行比较操作了，
                //     因而实际需要进行比较操作的元素个数为 n - i。
                // -1：是因为每次比较操作都是从0开始，和下一个元素进行比较，
                //    当迭代到最后一个需要比较的元素时，后面已经没有元素可比较了或者后面的元素已经是有序的，因此
                //    对于最后一个元素不必进行比较，因而每一趟迭代最多只需比较 n - i - 1 次操作。
                for (size_t j = 0; j < data.size() - i - 1; j++) {
                    if (data[j] > data[j+1])
                        std::swap(data[j], data[j+1]);
                }
            }
        }

        // 对于待排序的数组近乎是有序的时候，特别有用
        // 1. 这里的近乎有序指的是待排序的数组只有前面少部分数据发生混乱，发生混乱的数据越靠前，
        // 对于冒泡排序来说越接近有序，使用优化版的冒泡排序越快。
        //  例如：1 2 4 3 5 7 9 10 11 12 13 ... (13 后面还有1000000个数据，但是都是有序的)
        //      对这组数据进行冒泡排序时，使用优化版的冒泡排序时间复杂度趋近于 O(N)，只需要遍历一趟就可以了
        // 2. 如果待排序的特征是数组中的绝大多数的数据都是有序的，但是无序的数据或者混乱的元素大多集中在后半部分，
        // 那么即使是使用优化版的冒泡排序，执行时间也不会好到哪去。
        //  例如：1 2 4 5 6 7 ...（中间有 1000000 个元素都是有序的） 10000101 10000102 3 10000103
        //      对这组数据进行冒泡排序时，虽然前半部分大部分都是有序的，但是整个数组后面存在无序情况，使用
        //      冒泡排序时，需要执行的时间复杂度趋近于 O(N^2)。
        //      对上述数组进行冒泡排序时，执行第一趟冒泡的结果为：
        //      1 2 4 5 6 7 ...（中间有 1000000 个元素都是有序的） 10000101 3 10000102 10000103
        //      后面还需要执行将近N趟的冒泡，时间复杂度为 O(N^2)
        // 可能的解决方案：对于第2种待排序数组的特征情况，可以进行反向的冒泡排序，即从最后一个元素开始，依次
        // 往前两两元素进行比较，如果前一个元素（n-1）大于后一个元素(n)，就交换元素位置，这样，就把小的元素一步步往前
        // 冒泡到最前面了。
        // 3. 如果绝大多数的数据都是有序的，但是只有少部分随机的数据是无序的，则使用冒泡排序就没有相关好的优化方案了，
        // 时间复杂度基本为 O(N^2)了
        template <typename T>
        void BubbleSortAdvance(std::vector<T> &data) {
            for (size_t i = 0; i < data.size(); i++) {
                bool isSorted = true; // 假设待排序的数据是有序的
                for (size_t j = 0; j < data.size() - i - 1; j++) {
                    if (data[j] > data[j+1]) {
                        std::swap(data[j], data[j+1]);
                        isSorted = false;
                    }
                }

                // 如果数组已经有序了，就直接退出，不进行后续的排序
                // 因此其最好的时间复杂度仅为 O(N)
                if (isSorted) return;
            }
        }

    } // namespace Sort
}// namespace Algo

#endif //ALGORITHM_BUBBLESORT_HPP
